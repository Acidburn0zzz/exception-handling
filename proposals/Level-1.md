# Level 1 exception handling

Level 1 of exception handling is the MVP (minimal viable proposal) for
implementing exceptions in WebAssembly. As such, it doesn't include higher-level
concepts and structures. These concept and structures are introduced in later
levels, and either:

1. Improves readability by combining concepts in Level 1 into higher-level
   constructs, thereby reducing code size.
2. Allow performance improvements in the VM.
3. Introduce additional new functionality not available in Level 1.

This document supersedes the original [Exceptions Proposal].

[Exceptions Proposal]: https://github.com/WebAssembly/exception-handling/blob/master/proposals/Exceptions.md

## Overview

Exception handling allows code to break control flow when an exception is
thrown.  The exception can be any exception known by the WebAssembly module, or
it may an unknown exception that was thrown by a called imported function.

One of the problems with exception handling is that both WebAssembly and the
embedder probably have different notions of what exceptions are, but both must
be aware of the other.

It is difficult to define exceptions in WebAssembly because (in general) it
doesn't have knowledge of the embedder. Further, adding such knowledge to
WebAssembly would limit the ability for other embedders to support WebAssembly
exceptions.

One issue is that both sides need to know if an exception was thrown by the
other, because cleanup may need to be performed.

Another problem is that WebAssembly doesn't have direct access to the embedder's
memory.  As a result, WebAssembly defers the handling of exceptions to the
embedder.

To access exceptions, WebAssembly provides instructions to check if the
exception is one that WebAssembly understands. If so, the data of the
WebAssembly exception data is extracted and copied onto the stack, allowing
succeeding instructions to process the data.

Lastly, exception lifetimes must be maintained by the embedder, so that it can
collect and reuse the memory used by exceptions. This implies that the embedder
must know where exceptions are stored, so that it can determine when an
exception can be garbage collected.

This also implies that the embedder must provide a garbage collector for
exceptions.  For embedders that have garbage collection (such as JavaScript),
this is not a problem.

However, not all embedders may have a garbage collector. For this reason,
WebAssembly exceptions are designed to allow the use of reference counters (to
exceptions) to perform the the garbage collection in the embedder.

To do this, WebAssembly exceptions are immutable once created. This avoids
cyclic data structures that can't be garbage collected. It also means that
exceptions can't be stored into WebAssembly's linear memory. The rationale for
this is twofold:

* For security. Loads and stores do not guarantee that the data read was of the
  same type as stored. This allows spoofing of exception references that may
  allow a WebAssembly module to access data it should not know in the embedder.
  
* The embedder does not know the layout of data in linear memory, so it can't
  find places where exception references are stored.

Hence, while an exception reference is a new first class type, this proposal
disallows their usage in linear memory.

A WebAssembly exception is created when you throw it with the `throw`
instruction. Thrown exceptions are handled as follows:

1. They can be caught by a catch block in an enclosing try block of a function
   body. The caught exception is pushed onto the stack.

1. Throws not caught within a function body continue up the call stack, popping
   call frames, until an enclosing try block is found.
   
1. If the call stack is exhausted without any enclosing try blocks, embedder
   defines how to handle the uncaught exception.
   
### Event handling

This proposal focusses on adding exception handling, but tries to be more
general in its specification. This allows future generalizations to WebAssembly
without having to redo exception handling.

Events are generated by event yielding instructions. They yeild to an
appropriate event handler. The event handler is then run. That event handler
can either resume control at the point of the event handler, or optionally
resume by sending values back to the yielding instruction allow the
originating code to resume.

Exceptions are a special case of an event in that they never resume. Similarly,
a throw instruction is the yielding instruction of an exception, and the
corresponding catching block is the event handler of the exception.

An `event` is an internal construct in WebAssembly that is maintained by the
embedder. WebAssembly events are defined by a new `event section` of a
WebAssembly module.

The event section defines a list of event types that may be handled by the
module.  Each `event type` has (at a minimum) an `event specifier` and a `type
signature`. The event specifier defines the kind of event while the type
signature defines the list of values associated with the event.  Depending on
the value of the event specifier, additional values may be specified in the
event type.

For level 1, the only event specifier is the constant 0, and denotes that the
event is an `exception`. It has no additional values specified (other than the
type signature). Future extensions my add additional event specifiers, such as
resumable events.

The `type signature` of an event type is an index into the `type` section.  The
type signature is defined by a function type. The parameter list of the type
signature defines the list of values returned to the corresponding enclosing
catch. The result type defines the list of values to be used when resuming on an
event. For exceptions, that can't resume, the result type must always be type
'void'.

Note: Resumable events may not use the `throw` instruction. Rather, they may use
a new (yet to be defined) `yeild` instruction that passes value(s) to its
enclosing contexts. Such an instruction would allow the calling context to
return values back, and resume with the instruction following the yeild
instruction, based on the values returned.

Within a module, event types are identified by an `event index` to the [event
index space](#event-index-space). Each event index refers to a corresponding
runtime tag that uniquely identifies the corresponding event to be handled.  The
corresponding runtime tag is called an `event tag`.

Event types are numbered numerically, starting with the import section, and then
followed by event types in the event section.  Each event type within a module
are associated with unique event tags.

Event types can also be exported by adding appropriate descriptors in the export
section of the module. Each imported/exported event index must be named to
reconcile the corresponding (runtime) event tag.

### Exceptions

An `exception` is a WebAssembly event that can be thrown and caught.  That is,
an `exception type` is an event type whose event specifier is 0.  The `type
signature` of the exception is the corresponding type signature of the event
type. That is, the parameter list of the type signature defines the list of
values associated with the exception, and the result type must be type `void`.

Exceptions are identified by the by the corresponding event index, and is called
an `exception index`. The corresponding (runtime) event tag is called the
`exception tag`.  Like all event types, each exception type within a module
(i.e. in the event and import sections) are associated with unique exception
tags.

Exception indices are used by:

1. The `throw` instruction which creates a WebAssembly exception with the
   corresponding exception tag, and then throws it.

2. The `if_except` instruction that queries an exception to see if the exception
   tag corresponding to the module's exception index. If true it pushes the
   corresponding values of the exception onto the stack.
   
### The exception reference data type

Data types are extended to have a new `except_ref` type. The representation is
left to the embedder.

### Try and catch blocks

A _try block_ defines a list of instructions that may need to process exceptions
and/or clean up state when an exception is thrown. Like other higher-level
constructs, a try block begins with a `try` instruction, and ends with an `end`
instruction. That is, a try block is sequence of instructions having the
following form:

```
try block_type
  instruction*
catch
  instruction*
end
```

A try block ends with a `catch block` that is defined by the list of
instructions after the `catch` instruction. The catch block is the event handler
for all exceptions thrown in the try block.

Try blocks, like control-flow blocks, have a _block type_. The block type of a
try block defines the values yielded by the evaluation the try block when either
no exception is thrown, or the exception is successfully caught by the catch
block.

In the initial implementation, try blocks may only yield 0 or 1 values.

### Throwing an exception

The `throw` instruction takes an exception index as an immediate argument.  That
index is used to identify the exception tag to use to create and throw the
corresponding exception.

The values on top of the stack must correspond to the the type signature
associated with the exception index. These values are popped of the stack and
are used (along with the corresponding exception tag) to create the
corresponding exception value. Along with the values, a stack trace is also
associated with the exception. That exception is then thrown.

When an exception is thrown, the embedder searches for nearest enclosing try
block body that execution is in. That try block is called the _catching_ try
block.

If the throw appears within the body of a try block, it is the catching try
block.

If a throw occurs within a function body, and it doesn't appear inside the body
of a try block, the throw continues up the call stack until it is in the body of
an an enclosing try block, or the call stack is flushed. If the call stack is
flushed, the embeddder defines how to handle uncaught exceptions.  Otherwise, the
found enclosing try block is the catching try block.

A throw inside the body of a catch block is never caught by the corresponding
try block of the catch block, since instructions in the body of the catch block
are not in the body of the try block.

Once a catching try block is found for the thrown exception, the operand stack
is popped back to the size the operand stack had when the try block was entered,
and then an except_ref (for the exception) is pushed back onto the stack.

If control is transferred to the body of a catch block, and the last instruction
in the body is executed, control then exits the try block.

If the selected catch block does not throw an exception, it must yield the
value(s) expected by the corresponding catching try block. This includes popping
the caught except_ref.

Note that a caught exception except_ref value can be rethrown using the
`rethrow` instruction.

### Rethrowing an exception

The `rethrow` instruction takes the exception associated with the `except_ref`
on top of the stack, and rethrows that exception. A rethrow has the same effect
as a throw, other than an exception is not created. Rather, the referenced
exception on top of the stack is popped and then thrown.

### Exception data extraction

The `if_except block` defines a conditional query of the exception in the
except_ref on top of the stack. The except_ref is popped when queried. The
if_except block has two subblocks, the `then` and `else` subblocks, like that of
an `if` block. The then block is a sequence of instructions following the
`if_except` instruction. The else block begins with the `else` instruction.  The
scope of the if_except block is from the `if_except` instruction to the
corresponding `end` instruction.

That is, the forms of an if_except block is:

```
if_except block_type except_index
  Instruction*
else
  Instruction*
end
```

The conditional query of an exception succeeds when the exception in the
except_ref on the top of the stack has the corresponding exception tag (defined
by `except_index`). After the query, the except_ref is popped from the stack.

If the query succeeds, the values (associated with the exception value) are
extracted and pushed onto the stack, and control transfers to the instructions
in the then block. If the query fails, control is transfertd to the else block.

### Stack traces

When an exception is thrown, conceptually a runtime stack is associated with the
exception. However, WebAssembly does not have (direct) access to the stack
trace. Hence, it is left to the embedder to maintain and use at it sees fit.

## Changes to the text format.

This section describes change in the
[instruction syntax document](https://github.com/WebAssembly/spec/blob/master/document/core/instructions.rst).

### New instructions

The following rules are added to *instructions*:

```
  try resulttype instruction* catch instruction* end |
  except except_index |
  throw except_index |
  rethrow |
  if_except resulttype except_index then instruction* else instruction* end
```

Like the `block`, `loop`, and `if` instructions, the `try` and `if_except`
instructions are *structured* control flow instructions, and can be
labeled. This allows branch instructions to exit try and `if_except` blocks.

The `except_index` of the `throw` and `if_except` instructions defines the
exception type (and hence, exception tag) to create/extract form. See [event
index space](#event-index-space) for further clarification of exception
tags.

## Changes to Modules document.

This section describes change in the
[Modules document](https://github.com/WebAssembly/design/blob/master/Modules.md).

### Event index space

The `event index space` indexes all imported and internally-defined events,
assigning monotonically-increasing indices based on the order defined in the
import and event sections. Thus, the index space starts at zero with imported
events followed by internally-defined events in the [event
section](#event-section).

The event index space defines the (module) static version of runtine event
tags. These (runtime) event tags are guaranteed to be unique over all loaded
modules.

For event indices imported/exported, unique event tags are created for
each unique name imported/exported, and are aliased to the corresponding
event index defined in each module.

## Changes to the binary model

This section describes changes in the [binary encoding design
document](https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md).


### Data Types

#### except_ref

An exception reference points to an exception. The size is fixed, but unknown in
WebAssembly.

### Language Types

| Opcode | Type constructor |
|--------|------------------|
| -0x0x5 |  `except_ref`    |

#### value_type

A `varint7` indicating a `value_type` is extended to include `except_ref` as
encoded above.

#### Other Types

##### event_type

An event specifier specifies the kind of event an event type represents. Currently,
the only value event specifier is:

| Name      | Value |
|-----------|-------|
| exception | 0     |


Each event type (defining an event tag) has (at a minimum) an event specifier
and a type signature.  Each event type begins with the fields

| Field       | Type        | Description                                    |
|-------------|-------------|------------------------------------------------|
| `specifier` | `varuint32` | The kind of event.                             |
| `type`      | `varuint32` | Index to the type defining its type signature. |


Followed by (based on specifier):

`exception`: No additional fields.

##### external_kind

A single-byte unsigned integer indicating the kind of definition being imported
or defined:

* `0` indicating a `Function` [import](Modules.md#imports) or [definition](Modules.md#function-and-code-sections)
* `1` indicating a `Table` [import](Modules.md#imports) or [definition](Modules.md#table-section)
* `2` indicating a `Memory` [import](Modules.md#imports) or [definition](Modules.md#linear-memory-section)
* `3` indicating a `Global` [import](Modules.md#imports) or [definition](Modules.md#global-section)
* `4` indicating an `Event` [import](#import-section) or [definition](#event-section)

### Module structure

#### High-level structure

A new event section is introduced and is named `event`. If included,
it must appear after immediately after the global section.

##### Event section

The `event` section is the named section 'event'. The event section declares a
list of event types for a module.

Currently, event kinds are:

| Field   | Type         | Description                               |
|---------|--------------|-------------------------------------------|
| count   | `varuint32`  | count of the number of events to follow   |
| entries | `event_type* | list of defined event types.              |

##### Import section

The import section is extended to include exception definitions by extending an
`import_entry` as follows:

If the `kind` is `event`:

| Field | Type       | Description         |
|-------|------------|---------------------|
| event | event_type | The event to import |

##### Export section

The export section is extended to reference event types by extending an
`export_entry` as follows:

If the `kind` is `Event`, then the `index` is into the corresponding
event index in the [event index space](#event-index-space).

##### Name section

The set of known values for `name_type` of a name section is extended as
follows:

| Name Type                   | Code | Description                          |
|-----------------------------|------|--------------------------------------|
| [Function](#function-names) | `1`  | Assigns names to functions           |
| [Local](#local-names)       | `2`  | Assigns names to locals in functions |
| [Event](#event-names)       | `3`  | Assigns names to event types         |

###### Event names

The event names subsection is a `name_map` which assigns names to a subset
of the event indices, defined in the import and event sections of the module.

### Control flow operators

The control flow operators are extended to define try blocks, catch blocks,
throws, and rethrows as follows:

| Name | Opcode | Immediates | Description |
| ---- | ---- | ---- | ---- |
| `try` | `0x06` | sig : `block_type` | begins a block which can handle thrown exceptions |
| `catch` | `0x07` | | begins the catch block of the try block |
| `throw` | `0x08` | index : `varint32` | Creates an exception defined by the exception `index`and then throws it |
| `rethrow` | `0x09` | | Pops the `except_ref` on top of the stack and throws it |
| `if_except` | `0x0a` | sig : `block_type` , index : `varuint32` | Begin exception data extraction if exception on stack was created using the corresponding exception `index` |

The *sig* fields of `block`, `if`, `try` and `if_except` operators are block
signatures which describe their use of the operand stack.
